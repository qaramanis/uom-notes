# Εξαντλητική Αναζήτηση
## Αρχείο PDF [[Διάλεξη 06 - Εξαντλητική αναζήτηση.pdf|εδώ]] ![[Διάλεξη 06 - Εξαντλητική αναζήτηση.pdf]]
## Βασικός Ορισμός

• **Εξαντλητική Αναζήτηση**: Μέθοδος ωμής βίας που αναζητά ένα στοιχείο με συγκεκριμένη ιδιότητα • **Εφαρμογή**: Συνδυαστικά αντικείμενα (συνδυασμούς, διατάξεις, υποσύνολα)

## Μεθοδολογία (3 Βήματα)

1. **Κατασκευή λίστας**: Δημιουργούμε όλες τις δυνατές λύσεις συστηματικά
    
    - Παρουσιάζονται όλες οι λύσεις
    - Καμία λύση δεν επαναλαμβάνεται
2. **Εξέταση λύσεων**: Εξετάζουμε μία προς μία, απορρίπτοντας τις μη ικανοποιητικές
    
    - Κρατάμε τη μέχρι στιγμής καλύτερη
3. **Ανακοίνωση αποτελέσματος**: Όταν τελειώσει η αναζήτηση, ανακοινώνεται ο νικητής
    

---

## Πρόβλημα Πλανόδιου Πωλητή (TSP)

### Ορισμός Προβλήματος

• **Στόχος**: Βρες τη συντομότερη διαδρομή που περνά από όλες τις πόλεις ακριβώς μία φορά • **Επιστροφή**: Πρέπει να επιστρέψει στην αφετηρία

### Αλγόριθμος

1. Θεωρούμε την πόλη 1 ως αρχικό και τελικό σημείο
2. Δημιουργούμε όλες τις (n-1)! παραλλαγές
3. Υπολογίζουμε το κόστος κάθε παραλλαγής
4. Επιστρέφουμε την παραλλαγή με το ελάχιστο κόστος

### Πολυπλοκότητα

• **Χρονική**: O(n!) • **Αιτιολόγηση**: Για n πόλεις έχουμε (n-1)! δυνατές διαδρομές

---

## Πρόβλημα του Σακιδίου (Knapsack Problem)

### Ορισμός Προβλήματος

• **Δεδομένα**: n αντικείμενα με βάρη w₁, w₂, ..., wₙ και αξίες v₁, v₂, ..., vₙ • **Περιορισμός**: Σάκος χωρητικότητας W • **Στόχος**: Βρες το πολυτιμότερο υποσύνολο που ταιριάζει στο σάκο

### Αλγόριθμος (Αναδρομική Προσέγγιση)

```c
int knapSack(int W, int wt[], int val[], int n) {
    // Βασική περίπτωση
    if (n == 0 || W <= 0) return 0;
    
    // Αν το βάρος υπερβαίνει τη χωρητικότητα
    if (wt[n-1] > W) 
        return knapSack(W, wt, val, n-1);
    
    // Επέστρεψε το μεγαλύτερο των δύο:
    // (1) με το n-οστό αντικείμενο
    // (2) χωρίς το n-οστό αντικείμενο
    else return max(
        val[n-1] + knapSack(W - wt[n-1], wt, val, n-1),
        knapSack(W, wt, val, n-1)
    );
}
```

### Πολυπλοκότητα

• **Χρονική**: O(2ⁿ) • **Αιτιολόγηση**: Για κάθε αντικείμενο έχουμε 2 επιλογές (να το πάρουμε ή όχι) • **Συνολικά υποσύνολα**: 2ⁿ δυνατοί συνδυασμοί

---

## Πρόβλημα της Ανάθεσης (Assignment Problem)

### Ορισμός Προβλήματος

• **Δεδομένα**: n άτομα και n εργασίες • **Κόστος**: C[i,j] = κόστος αν το άτομο i αναλάβει την εργασία j • **Στόχος**: Ανάθεση ενός ατόμου σε κάθε εργασία με ελάχιστο συνολικό κόστος

### Πολυπλοκότητα

• **Χρονική**: O(n!) • **Αιτιολόγηση**: n! δυνατοί συνδυασμοί ανάθεσης

---

## Συμπεράσματα

### Πλεονεκτήματα

• **Εγγυημένη βέλτιστη λύση**: Πάντα βρίσκει την καλύτερη απάντηση • **Απλότητα**: Εύκολη κατανόηση και υλοποίηση

### Μειονεκτήματα

• **Χρονική πολυπλοκότητα**: Εκτελούνται σε ρεαλιστικούς χρόνους μόνο για μικρά στιγμιότυπα • **Εκθετική ανάπτυξη**: Ο χρόνος εκτέλεσης αυξάνεται δραστικά με το μέγεθος

### Πότε Χρησιμοποιούμε

• **Εναλλακτικές λύσεις**: Κάποιες φορές υπάρχουν καλύτερες προσεγγίσεις • **Μοναδική λύση**: Μερικές φορές η εξαντλητική αναζήτηση είναι η μοναδική γνωστή λύση

---

## Σημαντικές Σημειώσεις για Εξετάσεις

• **Μάθετε τις πολυπλοκότητες**: O(n!), O(2ⁿ) • **Κατανοήστε τη λογική**: Κάθε πρόβλημα εξετάζει όλες τις δυνατές λύσεις • **Παραδείγματα**: Εξασκηθείτε στον υπολογισμό του πλήθους λύσεων για κάθε πρόβλημα