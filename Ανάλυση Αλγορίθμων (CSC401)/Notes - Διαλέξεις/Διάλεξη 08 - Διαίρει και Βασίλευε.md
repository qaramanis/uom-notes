# Διαίρει και Βασίλευε
## Αρχείο PDF [[Διάλεξη 08 - Διαίρει και Βασίλευε.pdf|εδώ]] ![[Διάλεξη 08 - Διαίρει και Βασίλευε.pdf]]

## Διάσχιση Δυαδικού Δένδρου Κατά Επίπεδα (BFS)

### Αλγόριθμος με Ουρά

- **Βήμα 1**: Δημιούργησε κενή ουρά q
- **Βήμα 2**: Τοποθέτησε τη ρίζα του δένδρου στην ουρά (push(root))
- **Βήμα 3**: Ενώ η ουρά δεν είναι κενή:
    - Τύπωσε το πρώτο στοιχείο της ουράς
    - Τοποθέτησε το αριστερό και δεξί παιδί στην ουρά
    - Εξήγαγε ένα στοιχείο από την ουρά

---

## Τεχνική Διαίρει και Βασίλευε (Divide and Conquer)

### Γενικές Αρχές

- **Στόχος**: Επίλυση προβλημάτων με διάσπαση σε μικρότερα υποπροβλήματα
- **Χαρακτηριστικά**: Αναδρομική προσέγγιση με συνδυασμό λύσεων

### Τρεις Φάσεις Εκτέλεσης

#### 1. **Διαίρει (Divide)**

- Διάσπαση προβλήματος σε υποπροβλήματα μικρότερων στιγμιοτύπων
- Συνήθως k=2 υποπροβλήματα

#### 2. **Κυρίευε (Conquer)**

- Επίλυση υποπροβλημάτων αναδρομικά
- Άμεση επίλυση αν είναι μικρού μεγέθους

#### 3. **Συνδύασε (Combine)**

- Συνδυασμός επιμέρους λύσεων για τη λύση του αρχικού προβλήματος

### Αρχή της Εξισορρόπησης

- **Κανόνας**: Διατήρηση ισορροπίας μεταξύ μεγεθών υποπροβλημάτων
- **Βέλτιστη περίπτωση**: n₁ = n₂ = n/2

### Χρόνος Εκτέλεσης

```
T(n) = D(n) + Σ(k, i=1) S(nᵢ) + C(n)
```

Όπου:

- **D(n)**: Χρόνος διάσπασης
- **S(n)**: Χρόνος επίλυσης υποπροβλήματος
- **C(n)**: Χρόνος συνδυασμού

---

## Παραδείγματα Εφαρμογής

### 1. Υπολογισμός Δύναμης

#### Κλασικός Αναδρομικός Αλγόριθμος

```c
int power(int base, int n) {
    if (n != 0)
        return (base * power(base, n - 1));
    else
        return 1;
}
```

- **Πολυπλοκότητα**: O(n)
- **Χρόνος**: T(n) = T(n-1) + O(1)

#### Βελτιωμένος Κώδικας (Διαίρει και Βασίλευε)

```c
int power(int base, int n) {
    int temp;
    if(n == 0) return 1;
    temp = power(base, n/2);
    if (n%2 == 0)
        return temp*temp;
    else
        return base*temp*temp;
}
```

- **Πολυπλοκότητα**: O(lg n)
- **Χρόνος**: T(n) = T(n/2) + O(1)

### 2. Ταξινόμηση με Συγχώνευση (Merge Sort)

#### Διαδικασία

1. **Διαίρεσε** την ακολουθία σε δύο υπακολουθίες n/2 στοιχείων
2. **Ταξινόμησε** τις δύο υπακολουθίες αναδρομικά
3. **Συγχώνευσε** τις ταξινομημένες υπακολουθίες

#### Πολυπλοκότητα

- **Χρόνος εκτέλεσης**: O(n lg n)
- **Χώρος**: O(n)
- **Αναδρομική σχέση**: T(n) = 2T(n/2) + n

#### Πλεονεκτήματα/Μειονεκτήματα

- **Πλεονεκτήματα**: Σταθερή πολυπλοκότητα O(n lg n)
- **Μειονεκτήματα**: Απαιτεί πρόσθετο χώρο O(n)

### 3. Γρήγορη Ταξινόμηση (Quick Sort)

#### Διαδικασία

1. **Επιλογή pivot**: Διάλεξε στοιχείο ως άξονα
2. **Partition**: Χώρισε σε δύο υποπίνακες (μικρότερα/μεγαλύτερα από pivot)
3. **Αναδρομή**: Εφάρμοσε το ίδιο στους υποπίνακες

#### Πολυπλοκότητα

- **Καλύτερη περίπτωση**: O(n lg n) - ισορροπημένη διάσπαση
- **Χειρότερη περίπτωση**: O(n²) - μη ισορροπημένη διάσπαση
- **Χώρος**: O(1) in-place

### 4. Ελάχιστη Απόσταση Σημείων

#### Πρόβλημα

- **Στόχος**: Εύρεση δύο πλησιέστερων σημείων σε n σημεία στο k-διάστατο χώρο
- **Ωμή βία**: O(n²) συγκρίσεις

#### Λύση με Διαίρει και Βασίλευε

1. **Ταξινόμηση** σημείων ως προς x συντεταγμένη
2. **Διάσπαση** σε δύο υποσύνολα με κάθετη γραμμή xₘᵢd
3. **Αναδρομική επίλυση** για αριστερά και δεξιά σημεία
4. **Έλεγχος λωρίδας** πλάτους d γύρω από xₘᵢd
5. **Βελτιστοποίηση**: Έλεγχος μόνο 7 σημείων για κάθε σημείο

#### Πολυπλοκότητα

- **Χρόνος**: O(n lg n)
- **Χρόνος λωρίδας**: O(n) - όχι O(n²)

### 5. Πολλαπλασιασμός Πινάκων

#### Κλασικός Αλγόριθμος

- **Πολυπλοκότητα**: O(n³) πολλαπλασιασμοί και προσθέσεις
- **Τύπος**: cᵢ,ⱼ = Σ(k=1 to n) aᵢ,ₖ × bₖ,ⱼ

#### Αλγόριθμος Διαίρει και Βασίλευε

- **Διάσπαση**: Πίνακες n×n σε τέσσερις υποπίνακες n/2 × n/2
- **Αναδρομή**: 8 πολλαπλασιασμοί υποπινάκων
- **Πολυπλοκότητα**: O(n³) - ίδια με κλασικό

#### Αλγόριθμος Strassen

- **Καινοτομία**: 7 πολλαπλασιασμοί αντί για 8
    
- **Προϋπολογισμοί**:
    
    - p₁ = a(f - h)
    - p₂ = (a + b)h
    - p₃ = (c + d)e
    - p₄ = d(g - e)
    - p₅ = (a + d)(e + h)
    - p₆ = (b - d)(g + h)
    - p₇ = (a - c)(e + f)
- **Αποτέλεσμα**:
    
    ```
    [ae + bg    af + bh]   [p₅+p₄-p₂+p₆   p₁+p₂    ]
    [ce + dg    cf + dh] = [p₃+p₄         p₅+p₁-p₃-p₇]
    ```
    
- **Πολυπλοκότητα**: O(n^2.81) - βελτίωση έναντι O(n³)
    

---

## Βασικές Αρχές Ανάλυσης

### Κύριο Θεώρημα (Master Theorem)

Για αναδρομικές σχέσεις της μορφής: T(n) = aT(n/b) + f(n)

### Συγκριτικά Αποτελέσματα

|Αλγόριθμος|Πολυπλοκότητα|Χαρακτηριστικά|
|---|---|---|
|Κλασικός Power|O(n)|Γραμμική αναδρομή|
|Βελτιωμένος Power|O(lg n)|Διαίρει και βασίλευε|
|Merge Sort|O(n lg n)|Σταθερή απόδοση|
|Quick Sort|O(n lg n) - O(n²)|Εξαρτάται από pivot|
|Κλασικός Πολλαπλασιασμός|O(n³)|Τρεις βρόχοι|
|Strassen|O(n^2.81)|Μειωμένοι πολλαπλασιασμοί|

---

## Βασικά Συμπεράσματα

### Οφέλη Τεχνικής

- **Βελτίωση πολυπλοκότητας** από γραμμική σε λογαριθμική
- **Αποδοτικότητα** για μεγάλα προβλήματα
- **Παραλληλοποίηση** υποπροβλημάτων

### Κλειδιά Επιτυχίας

- **Ισορροπημένη διάσπαση** υποπροβλημάτων
- **Αποδοτικός συνδυασμός** λύσεων
- **Σωστή επιλογή** βασικής περίπτωσης

### Περιορισμοί

- **Επιπλέον μνήμη** σε ορισμένες περιπτώσεις
- **Πολυπλοκότητα υλοποίησης** για ορισμένους αλγορίθμους
- **Σταθερές** που μπορεί να επηρεάζουν πρακτική απόδοση