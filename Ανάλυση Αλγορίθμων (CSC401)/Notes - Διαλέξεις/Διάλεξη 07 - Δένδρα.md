# Δένδρα
## Αρχείο PDF [[Διάλεξη 07 - Δένδρα.pdf|εδώ]] ![[Διάλεξη 07 - Δένδρα.pdf]]

## Γενικά για Δένδρα

### Βασικοί Ορισμοί

- **Δένδρο**: Αποτελείται από κόμβους και ακμές που τους συνδέουν
- **Κόμβος**: Έχει παιδιά (εκτός των φύλλων) και έναν μόνο γονέα (εκτός της ρίζας)
- **Διαδρομή (path)**: Ακολουθία κόμβων από έναν κόμβο σε άλλον
- **Μήκος διαδρομής**: Αριθμός ακμών στη διαδρομή
- **Επίπεδο/Βάθος κόμβου**: Μήκος διαδρομής από τη ρίζα στον κόμβο
- **Ύψος δένδρου**: Μέγιστο επίπεδο/βάθος των κόμβων
- **Βαθμός κόμβου**: Αριθμός παιδιών του κόμβου
- **Βαθμός δένδρου**: Μέγιστος βαθμός των κόμβων

---

## Δυαδικά Δένδρα

### Χαρακτηριστικά

- Έχουν βαθμό 2 (κάθε κόμβος έχει το πολύ 2 παιδιά)
- **Πλήρες δυαδικό δένδρο**: Έχει μέγιστο αριθμό κόμβων σε κάθε επίπεδο πλην του τελευταίου

### Αναπαράσταση

#### Συνεχόμενη (με πίνακα)

- Ρίζα στη θέση 0
- Αν κόμβος στη θέση k → αριστερό παιδί: 2k+1, δεξί παιδί: 2k+2

#### Συνδεδεμένη

- Χρήση δεικτών (left, right)

```c
typedef struct node{
    int data;
    struct node *left;
    struct node *right;
} TreeNode;
```

---

## Διαπεράσεις Δυαδικών Δένδρων

### Τύποι Διαπέρασης

- **Προδιατεταγμένη (ΡΑΔ)**: Ρίζα → Αριστερό → Δεξί
- **Ενδοδιατεταγμένη (ΑΡΔ)**: Αριστερό → Ρίζα → Δεξί
- **Μεταδιατεταγμένη (ΑΔΡ)**: Αριστερό → Δεξί → Ρίζα
- **Κατά σειρά επιπέδων**: Διασχίζουμε επίπεδα από πάνω προς κάτω

### Παράδειγμα Κώδικα

```c
// προδιατεταγμένη διαπέραση
void preorder(TreeNode *t) {
    if (t) {
        visit(t); 
        preorder(t->left); 
        preorder(t->right); // Ρ Α Δ
    }
}

// ενδοδιατεταγμένη διαπέραση
void inorder(TreeNode *t){
    if (t) {
        inorder(t->left); 
        visit(t); 
        inorder(t->right); // Α Ρ Δ
    }
}
```

---

## Δένδρα Σωροί (Heap Trees)

### Ορισμός

- **Σωρός ελαχίστων (minHeap)**: Κάθε κόμβος ≤ από τα παιδιά του
- **Σωρός μεγίστων (maxHeap)**: Κάθε κόμβος ≥ από τα παιδιά του
- Είναι πλήρες δυαδικό δένδρο
- Το ελάχιστο/μέγιστο στοιχείο βρίσκεται στη ρίζα

### Λειτουργίες

#### Εισαγωγή Στοιχείου

- **Πολυπλοκότητα**: O(log n)
- **Διαδικασία**:
    1. Προσθήκη στο τέλος του σωρού
    2. Αντιμεταθέσεις προς τα πάνω μέχρι τη σωστή θέση

#### Διαγραφή Ρίζας

- **Πολυπλοκότητα**: O(log n)
- **Διαδικασία**:
    1. Αντικατάσταση ρίζας με το τελευταίο στοιχείο
    2. Αντιμεταθέσεις προς τα κάτω μέχρι τη σωστή θέση

### Αλγόριθμος Ταξινόμησης Σωρού (Heap Sort)

1. **Κατασκευή σωρού**: O(n)
2. **Διαδοχική εξαγωγή ρίζας**: O(n log n)
3. **Συνολική πολυπλοκότητα**: **O(n log n)**

#### Τύποι Ταξινόμησης

- **Αύξουσα σειρά**: Χρήση σωρού ελαχίστων
- **Φθίνουσα σειρά**: Χρήση σωρού μεγίστων

---

## Δυαδικά Δένδρα Αναζήτησης (BST)

### Ιδιότητες

- **Αριστερό υποδένδρο**: Όλες οι τιμές < τιμή κόμβου
- **Δεξί υποδένδρο**: Όλες οι τιμές > τιμή κόμβου

### Λειτουργίες

#### Αναζήτηση

- **Πολυπλοκότητα**: O(h) όπου h = ύψος δένδρου
- **Διαδικασία**: Σύγκριση με ρίζα και κατεύθυνση προς αριστερά ή δεξιά

#### Εισαγωγή

- **Πολυπλοκότητα**: O(h)
- **Διαδικασία**: Εύρεση της κατάλληλης θέσης ακολουθώντας τις ιδιότητες BST

#### Διαγραφή

- **Πολυπλοκότητα**: O(h)
- **Τρεις περιπτώσεις**:
    1. **Φύλλο**: Απλή διαγραφή
    2. **Ένα παιδί**: Αντικατάσταση με το παιδί
    3. **Δύο παιδιά**: Αντικατάσταση με προκάτοχο ή διάδοχο

### Εύρεση Ελαχίστου/Μεγίστου

- **Ελάχιστο**: Πάντα αριστερότερο φύλλο
- **Μέγιστο**: Πάντα δεξιότερο φύλλο

```c
TreeNode* minNode(TreeNode* n) { 
    while (n->left != NULL) { 
        n = n->left;
    }
    return n;
}

TreeNode* maxNode(TreeNode* n) { 
    while (n->right != NULL) { 
        n = n->right; 
    }
    return n;
}
```

### Πολυπλοκότητα Πράξεων

- **Ισοζυγισμένο δένδρο**: O(log n)
- **Χειρότερη περίπτωση** (λοξό δένδρο): O(n)

---

## Ισοζυγισμένα Δένδρα

### Ορισμός Ισοζυγισμένου Δένδρου

**Ισοζυγισμένο δένδρο**: Το αριστερό και δεξί υποδένδρο κάθε κόμβου διαφέρουν στο ύψος το πολύ κατά 1

### Πλεονεκτήματα

- Εξασφαλίζουν **O(log n)** απόδοση για όλες τις λειτουργίες
- Αποφυγή του χειρότερου σεναρίου O(n)

---

## Εκτός Ύλης Εξετάσεων

> **Σημείωση**: Τα παρακάτω θέματα δεν περιλαμβάνονται στις εξετάσεις:

### AVL Δένδρα

- Αυτο-εξισορροπούμενα δένδρα
- Συντελεστής ισορροπίας: -1, 0, ή 1
- Περιστροφές για διατήρηση ισορροπίας

### B-Δένδρα

- Χρήση σε συστήματα διαχείρισης βάσεων δεδομένων
- Πολυδιακλαδωμένα δένδρα
- Ιδανικά για αποθήκευση σε δίσκο

---

## Πρακτικές Εφαρμογές

- **Δένδρα σωροί** → Αλγόριθμοι ταξινόμησης, priority queues
- **BST** → Δομές δεδομένων αναζήτησης, λεξικά
- **AVL/Red-Black trees** → Εξισορροπημένες δομές για βελτιστοποιημένη απόδοση

---

## Βασικές Αρχές για Εξετάσεις

### Θυμήσου

1. **Διαπεράσεις**: Προδιατεταγμένη (ΡΑΔ), Ενδοδιατεταγμένη (ΑΡΔ), Μεταδιατεταγμένη (ΑΔΡ)
2. **Heap Sort**: O(n log n) πολυπλοκότητα
3. **BST Ιδιότητες**: Αριστερά < Ρίζα < Δεξιά
4. **Ισορροπία**: Κλειδί για αποδοτικότητα O(log n)
5. **Τρόποι διαγραφής**: Φύλλο, ένα παιδί, δύο παιδιά