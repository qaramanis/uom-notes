# Μείωση και Κυριαρχία
## Αρχείο PDF [[Διάλεξη 09 - Μείωση και κυριαρχία.pdf|εδώ]] ![[Διάλεξη 09 - Μείωση και κυριαρχία.pdf]]

## Εισαγωγή στη Μείωση και Κυριαρχία (Decrease and Conquer)

### Τι είναι η τεχνική Μείωσης και Κυριαρχίας;

- **Ορισμός**: Η τεχνική βασίζεται στην εκμετάλλευση της σχέσης που υφίσταται μεταξύ της λύσης μιας δεδομένης έκφανσης ενός προβλήματος και της λύσης μιας μικρότερης έκφανσης του ίδιου προβλήματος
- **Βασική ιδέα**: Διαιρούμε το πρόβλημα σε μικρότερα κομμάτια για να το λύσουμε πιο εύκολα

### Τύποι Υλοποίησης

- **Top-down (από πάνω προς τα κάτω)**: Αναδρομικές υλοποιήσεις
- **Bottom-up (από κάτω προς τα πάνω)**: Επαναληπτικές υλοποιήσεις

---

## Τρεις Παραλλαγές της Τεχνικής

### 1. Μείωση κατά μία σταθερά

- Μειώνουμε το μέγεθος του προβλήματος κατά μία σταθερά σε κάθε επανάληψη
- Συνήθως η σταθερά είναι 1

### 2. Μείωση κατά έναν σταθερό παράγοντα

- Μειώνουμε το μέγεθος κατά τον ίδιο σταθερό παράγοντα
- Συνήθως διαιρούμε δια 2
- Αποφέρει αλγόριθμους λογαριθμικής τάξης

### 3. Μείωση μεταβλητού μεγέθους

- Το πρότυπο μείωσης ποικίλλει από επανάληψη σε επανάληψη
- Η μείωση εξαρτάται από τα δεδομένα

---

## Μείωση κατά μία Σταθερά

### Παράδειγμα: Ταξινόμηση με Εισαγωγή (Insertion Sort)

#### Πώς λειτουργεί;

1. **Ξεκινάμε από τη δεύτερη θέση** (δείκτης 1)
2. **Συγκρίνουμε** το τρέχον στοιχείο με τα προηγούμενα
3. **Μετακινούμε** τα μεγαλύτερα στοιχεία μία θέση δεξιά
4. **Εισάγουμε** το τρέχον στοιχείο στη σωστή θέση
5. **Επαναλαμβάνουμε** για όλα τα στοιχεία

#### Παράδειγμα Εκτέλεσης

```
Αρχικός πίνακας: [23, 42, 10, 100, 8, 44, 12]

Βήμα 1: [23, 42, 10, 100, 8, 44, 12] → δεν αλλάζει τίποτα
Βήμα 2: [23, 10, 42, 100, 8, 44, 12] → το 10 μετακινείται
Βήμα 3: [10, 23, 42, 100, 8, 44, 12] → το 10 πάει στην αρχή
...
Τελικό: [8, 10, 12, 23, 42, 44, 100]
```

#### Κώδικας C

```c
void insertionSort(int arr[], int n) {
    int i, key, j;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        
        // Μετακίνηση στοιχείων μεγαλύτερων από key
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
```

#### Ανάλυση Πολυπλοκότητας

- **Καλύτερη περίπτωση**: O(n) - πίνακας ήδη ταξινομημένος
- **Χειρότερη περίπτωση**: O(n²) - πίνακας αντίστροφα ταξινομημένος
- **Μέση περίπτωση**: O(n²)

---

## Μείωση κατά Σταθερό Παράγοντα

### Παράδειγμα: Δυαδική Αναζήτηση (Binary Search)

#### Πώς λειτουργεί;

1. **Συγκρίνουμε** το κλειδί με το μεσαίο στοιχείο
2. **Αν είναι ίσα** → τερματισμός (βρήκαμε το στοιχείο)
3. **Αν το κλειδί είναι μικρότερο** → αναζήτηση στο αριστερό μισό
4. **Αν το κλειδί είναι μεγαλύτερο** → αναζήτηση στο δεξιό μισό
5. **Επαναλαμβάνουμε** μέχρι να βρούμε το στοιχείο ή να εξαντληθεί ο πίνακας

#### Προαπαιτούμενα

- Ο πίνακας **πρέπει να είναι ταξινομημένος**

#### Παράδειγμα Εκτέλεσης

```
Πίνακας: [1, 3, 4, 8, 9, 13, 15, 20, 24, 38, 40, 55, 67, 68, 70, 79]
Αναζήτηση: 70

Βήμα 1: Μέση = 20, 70 > 20 → δεξιό μισό
Βήμα 2: Μέση = 55, 70 > 55 → δεξιό μισό  
Βήμα 3: Μέση = 68, 70 > 68 → δεξιό μισό
Βήμα 4: Μέση = 70 → ΒΡΕΘΗΚΕ!
```

#### Κώδικας C

```c
int binarySearch(int arr[], int l, int r, int x) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
        
        // Αν το στοιχείο βρίσκεται στη μέση
        if (arr[mid] == x)
            return mid;
            
        // Αν το στοιχείο είναι μικρότερο από το mid
        if (arr[mid] > x)
            return binarySearch(arr, l, mid - 1, x);
            
        // Διαφορετικά, αναζήτηση στο δεξιό μισό
        return binarySearch(arr, mid + 1, r, x);
    }
    return -1; // Δεν βρέθηκε
}
```

#### Ανάλυση Πολυπλοκότητας

- **Καλύτερη περίπτωση**: O(1) - το στοιχείο βρίσκεται στη μέση
- **Χειρότερη περίπτωση**: O(log n)
- **Μέση περίπτωση**: O(log n)

---

## Μείωση Μεταβλητού Μεγέθους

### Παράδειγμα: Αναζήτηση Παρεμβολής (Interpolation Search)

#### Πώς λειτουργεί;

- **Βελτίωση της Binary Search** για ομοιόμορφα κατανεμημένα δεδομένα
- Αντί να πάει πάντα στη μέση, **υπολογίζει έξυπνα** πού να ψάξει
- Χρησιμοποιεί τον τύπο: `pos = l + [(h-l)/(T[h]-T[l])] * (x-T[l])`

#### Πότε είναι αποδοτική;

- Όταν τα δεδομένα είναι **ομοιόμορφα κατανεμημένα**
- Παράδειγμα: Αναζήτηση λέξης σε λεξικό (η λέξη "Μήλο" θα είναι κοντά στη μέση)

#### Βήματα Αλγορίθμου

1. **Υπολογισμός θέσης** με τον τύπο παρεμβολής
2. **Έλεγχος ταίριασμα** στη θέση pos
3. **Αν βρέθηκε** → επιστροφή θέσης
4. **Αν το κλειδί < arr[pos]** → αναζήτηση αριστερά
5. **Αν το κλειδί > arr[pos]** → αναζήτηση δεξιά
6. **Επανάληψη** μέχρι εύρεση ή εξάντληση

#### Παράδειγμα Εκτέλεσης

```
Αναζήτηση 18 στον πίνακα: [10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47]

l=0, h=14, arr[0]=10, arr[14]=47
pos = 0 + (14-0)/(47-10) * (18-10) = 0 + 14/37 * 8 ≈ 3

Έλεγχος θέσης 3: arr[3] = 16
18 > 16 → αναζήτηση δεξιά

l=4, h=14, arr[4]=18, arr[14]=47  
pos = 4 + (14-4)/(47-18) * (18-18) = 4

Έλεγχος θέσης 4: arr[4] = 18 → ΒΡΕΘΗΚΕ!
```

#### Ανάλυση Πολυπλοκότητας

- **Καλύτερη περίπτωση**: O(1)
- **Μέση περίπτωση**: O(log log n) - για ομοιόμορφα δεδομένα
- **Χειρότερη περίπτωση**: O(n) - για άτυπα κατανεμημένα δεδομένα

---

## Σύγκριση Πολυπλοκοτήτων

|Αλγόριθμος|Καλύτερη|Μέση|Χειρότερη|
|---|---|---|---|
|**Insertion Sort**|O(n)|O(n²)|O(n²)|
|**Binary Search**|O(1)|O(log n)|O(log n)|
|**Interpolation Search**|O(1)|O(log log n)|O(n)|

---

## Κύρια Σημεία για Εξετάσεις

### Μείωση και Κυριαρχία - Βασικές Αρχές

- **Στόχος**: Μείωση του μεγέθους του προβλήματος σε κάθε βήμα
- **Τρεις τύποι**: Σταθερή μείωση, σταθερός παράγοντας, μεταβλητή μείωση
- **Υλοποίηση**: Αναδρομική (top-down) ή επαναληπτική (bottom-up)

### Insertion Sort - Κλειδιά

- **Τεχνική**: Μείωση κατά 1
- **Λειτουργία**: Εισαγωγή κάθε στοιχείου στη σωστή θέση
- **Πολυπλοκότητα**: O(n²) στη γενική περίπτωση

### Binary Search - Κλειδιά

- **Τεχνική**: Μείωση κατά παράγοντα 2
- **Προϋπόθεση**: Ταξινομημένος πίνακας
- **Πολυπλοκότητα**: O(log n)

### Interpolation Search - Κλειδιά

- **Τεχνική**: Μείωση μεταβλητού μεγέθους
- **Πλεονέκτημα**: Καλύτερη από binary search για ομοιόμορφα δεδομένα
- **Πολυπλοκότητα**: O(log log n) στην καλύτερη περίπτωση

---

## Συμβουλές για τις Εξετάσεις

1. **Καταλάβετε τη διαφορά** μεταξύ των τριών τύπων μείωσης
2. **Θυμηθείτε τις πολυπλοκότητες** και πότε εφαρμόζεται η καθεμία
3. **Εξασκηθείτε στην εκτέλεση** των αλγορίθμων βήμα-βήμα
4. **Προσέξτε τις προϋποθέσεις** (π.χ. ταξινομημένος πίνακας για αναζήτηση)